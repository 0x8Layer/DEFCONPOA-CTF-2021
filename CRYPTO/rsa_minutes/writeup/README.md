# RSA Minutes
### _CRYPTO_

Esse desafio pedia para analisar o seguinte "código":
```
while True:
	minute = get_minute()
	if minute is prime:
	    p = minute
	q = getPrime(1024)
	e = 65537
	n = p*q
	flag = "flag"
	c = pow(hex(flag), e, n)

	print(c, e, n)
```

Esse código pegava o minuto atual, verificava se esse era primo e se fosse utilizava-o como p. E, por fim, encriptava a flag. O único porém desse desafio é que o servidor só respondia em minutos primos, então era necessário esperar um certo tempo até a resposta.

A forma esperada de resolução desse desafio: conectar no servidor e ficar esperando a resposta do mesmo. Quando o servidor respondesse, deveríamos pegar o horário da resposta, pois assim teríamos o p e consequentemente o q (pois o n é p*q).

Outra forma de resolução: pegar o n e buscar no factordb (link - http://factordb.com/index.php).

Após encontrar o p e o q, apenas era necessário fazer o exponencial inverso e assim, obteríamos a flag.

```
"""
{'c': 887897038970596582412415061361929382690361134932417483950437617505035077362271841813140065069513799971691248075537414011457482353808431879424096566207650218227943443403786718525806137500346679301592077874921945546655453231417182480020224174909027276166740415847823022221269280185336572812599573745091171968735, 'e': 65537, 'n': 1254336893191635508174753124182040315503489334417066797513160588510578005416468136118154196967736520550109127021188786141299126295669272533144790081870580188039960315344633971517649058338796045997588186584755041753100901839081179585517000072741006463455382413606865710592958259485128540203378190324454492065579}
"""
from Crypto.Util.number import inverse
n = 1254336893191635508174753124182040315503489334417066797513160588510578005416468136118154196967736520550109127021188786141299126295669272533144790081870580188039960315344633971517649058338796045997588186584755041753100901839081179585517000072741006463455382413606865710592958259485128540203378190324454492065579
e = 65537
c = 887897038970596582412415061361929382690361134932417483950437617505035077362271841813140065069513799971691248075537414011457482353808431879424096566207650218227943443403786718525806137500346679301592077874921945546655453231417182480020224174909027276166740415847823022221269280185336572812599573745091171968735
p = 13
q = n//p
phi = (p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(bytes.fromhex(hex(m)[2:]))
```

FLAG:
``` DC5551{b4by_r$4_4fun} ```
